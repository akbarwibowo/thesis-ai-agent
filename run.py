#!/usr/bin/env python3
"""
AI Crypto Analyst - Main Entry Point
====================================

This is the main entry point for the AI Crypto Analyst application.
Run this file to start the complete analysis pipeline.

Usage:
    python run.py
    python run.py --help
    python run.py --debug
    python run.py --max-tokens 50
    python run.py --skip-scraping
"""

import sys
import os
import argparse
import logging
from pathlib import Path
from datetime import datetime
from typing import Optional, Tuple, Any

# Setup project root and Python path
PROJECT_ROOT = Path(__file__).parent.absolute()
sys.path.insert(0, str(PROJECT_ROOT))


class AnalysisError(Exception):
    """Custom exception for analysis errors."""
    pass


def setup_logging(debug: bool = False) -> logging.Logger:
    """Set up logging configuration.
    
    Args:
        debug: Enable debug level logging if True
        
    Returns:
        Configured logger instance
    """
    level = logging.DEBUG if debug else logging.INFO
    
    # Create logs directory if it doesn't exist
    logs_dir = PROJECT_ROOT / 'logs'
    logs_dir.mkdir(exist_ok=True)
    
    # Setup logging configuration
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler(logs_dir / 'ai_analyst.log', mode='w', encoding='utf-8')
        ]
    )
    
    # Create and return logger for this module
    logger = logging.getLogger('ai_crypto_analyst')
    return logger


def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments.
    
    Returns:
        Parsed command line arguments
    """
    parser = argparse.ArgumentParser(
        description='AI Crypto Analyst - Automated cryptocurrency market analysis',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python run.py                          # Run with default settings
  python run.py --debug                  # Run with debug logging
  python run.py --max-tokens 100         # Limit analysis to 100 tokens
  python run.py --skip-scraping          # Use only existing data
  python run.py --save-report my_report.md  # Custom output filename
        """
    )
    
    parser.add_argument(
        '--debug', 
        action='store_true',
        help='Enable debug logging'
    )
    
    parser.add_argument(
        '--max-tokens',
        type=int,
        default=None,
        help='Maximum number of tokens to analyze (default: unlimited)',
        metavar='N'
    )
    
    parser.add_argument(
        '--skip-scraping',
        action='store_true',
        help='Skip data scraping and use only existing database content'
    )
    
    parser.add_argument(
        '--save-report',
        type=str,
        default='analysis_report.md',
        help='Filename to save the final report (default: analysis_report.md)',
        metavar='FILENAME'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='AI Crypto Analyst v1.0.0'
    )
    
    return parser.parse_args()


def create_markdown_report(report_content: str) -> str:
    """Create Markdown formatted report.
    
    Args:
        report_content: The raw report content
        
    Returns:
        Markdown formatted report content
    """
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    markdown_content = f"""# 🚀 AI Crypto Analyst Report

    *Generated on: {timestamp}*

    ---

    {report_content}

    ---

    *Report generated by AI Crypto Analyst v1.0.0*
    """
    
    return markdown_content


def save_report_to_file(report_content: str, filename: str, logger: logging.Logger) -> bool:
    """Save the analysis report to a Markdown file.
    
    Args:
        report_content: The report content to save
        filename: Output filename
        logger: Logger instance
        
    Returns:
        True if successful, False otherwise
    """
    try:
        # Validate filename
        if not filename.endswith('.md'):
            filename += '.md'
        
        # Create Markdown content
        markdown_content = create_markdown_report(report_content)
        
        # Ensure output directory exists
        report_path = PROJECT_ROOT / filename
        report_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write the file
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        # Success logging
        logger.info(f"✅ Report saved to: {report_path.absolute()}")
        logger.info(f"📖 Open the following file in a Markdown viewer or editor:")
        logger.info(f"   {report_path.absolute()}")
        
        return True
        
    except Exception as e:
        logger.error(f"❌ Failed to save report: {e}")
        return False


def print_banner() -> None:
    """Print application banner."""
    banner = """
╔══════════════════════════════════════════════════════════════════════════════╗
║                          🤖 AI CRYPTO ANALYST 🚀                            ║
║                                                                              ║
║  Automated cryptocurrency market analysis using advanced AI techniques      ║
║  📊 Narrative Analysis • 📈 Fundamental Analysis • 🔍 Technical Analysis     ║
╚══════════════════════════════════════════════════════════════════════════════╝
"""
    print(banner)


def validate_analysis_result(result: Any) -> str:
    """Validate and extract the analysis report from the result.
    
    Args:
        result: Analysis result from the main graph
        
    Returns:
        The final analysis report content
        
    Raises:
        AnalysisError: If validation fails
    """
    if not isinstance(result, dict):
        raise AnalysisError("Analysis returned unexpected result format")
    
    if "final_analysis_report" not in result:
        raise AnalysisError("Analysis did not generate a final report")
    
    final_report = result["final_analysis_report"]
    
    if not final_report or (isinstance(final_report, str) and final_report.strip() == ""):
        raise AnalysisError("Final analysis report is empty")
    
    return str(final_report)


def display_report_preview(report_content: str, preview_length: int = 500) -> None:
    """Display a preview of the analysis report.
    
    Args:
        report_content: The full report content
        preview_length: Maximum characters to show in preview
    """
    print("\n📋 REPORT PREVIEW:")
    print("-" * 60)
    
    # Clean up the content for console display (convert <br> tags to newlines)
    preview = report_content[:preview_length].replace('<br>', '\n')
    print(preview)
    
    if len(report_content) > preview_length:
        remaining = len(report_content) - preview_length
        print(f"\n... ({remaining:,} more characters - see Markdown file for full report)")
    
    print("-" * 60)


def run_analysis(args: argparse.Namespace, logger: logging.Logger) -> Tuple[str, int]:
    """Run the main analysis pipeline.
    
    Args:
        args: Parsed command line arguments
        logger: Logger instance
        
    Returns:
        Tuple of (report_content, exit_code)
    """
    try:
        # Import the main graph (only after path is set up)
        logger.info("📦 Loading AI analysis modules...")
        from agents.graphs.main_graph import main_graph
        
        # Create the main graph
        logger.info("🔨 Building analysis pipeline...")
        graph = main_graph()
        
        # Prepare the start command with configuration
        start_command = {
            "start_command": "START"
        }
        
        # TODO: Implement parameter passing when the graph supports it
        if args.max_tokens:
            logger.info(f"⚙️  Token limit configuration: {args.max_tokens}")
        
        if args.skip_scraping:
            logger.info("⚙️  Scraping skip configuration enabled")
        
        logger.info("🎯 Starting comprehensive market analysis...")
        logger.info("📊 This may take several minutes depending on data volume...")
        
        # Execute the analysis
        result = graph.invoke(start_command)  # type: ignore
        
        # Validate and extract the report
        final_report = validate_analysis_result(result)
        
        # Log success metrics
        report_length = len(final_report)
        logger.info(f"✅ Analysis completed successfully!")
        logger.info(f"📄 Generated report with {report_length:,} characters")
        
        return final_report, 0
        
    except ImportError as e:
        logger.error(f"❌ Failed to import required modules: {e}")
        print(f"\n💥 Module import error: {e}")
        print("🔧 Make sure all dependencies are installed: pip install -r requirements.txt")
        return "", 1
    
    except AnalysisError as e:
        logger.error(f"❌ Analysis validation failed: {e}")
        print(f"\n💥 Analysis error: {e}")
        return "", 1
    
    except Exception as e:
        logger.error(f"❌ Analysis failed with error: {e}")
        print(f"\n💥 Unexpected analysis error: {e}")
        
        if args.debug:
            logger.exception("Full error traceback:")
        else:
            print("🔍 Run with --debug flag for detailed error information")
        
        return "", 1


def main() -> int:
    """Main entry point for the AI Crypto Analyst application.
    
    Returns:
        Exit code (0 for success, non-zero for failure)
    """
    logger: Optional[logging.Logger] = None
    args: Optional[argparse.Namespace] = None
    
    try:
        # Parse command line arguments
        args = parse_arguments()
        
        # Print banner
        print_banner()
        
        # Setup logging
        logger = setup_logging(debug=args.debug)
        
        # Log startup information
        logger.info("🚀 Starting AI Crypto Analyst...")
        logger.info(f"📁 Project root: {PROJECT_ROOT}")
        logger.info(f"🔧 Debug mode: {'ON' if args.debug else 'OFF'}")
        
        if args.max_tokens:
            logger.info(f"🎯 Token analysis limit: {args.max_tokens}")
        
        if args.skip_scraping:
            logger.info("⏭️  Skipping data scraping - using existing data only")
        
        # Run the analysis
        report_content, exit_code = run_analysis(args, logger)
        
        if exit_code != 0:
            return exit_code
        
        # Save report to file
        logger.info("💾 Saving analysis report...")
        save_success = save_report_to_file(report_content, args.save_report, logger)
        
        # Display completion summary
        print("\n" + "="*80)
        print("🎉 ANALYSIS COMPLETE!")
        print("="*80)
        
        if save_success:
            print(f"📁 Report saved to: {args.save_report}")
            print(f"📝 Open the Markdown file in your preferred editor or viewer")
        else:
            logger.warning("⚠️  Report saving failed, but analysis was successful")
        
        # Show report preview
        display_report_preview(report_content)
        
        logger.info("🎯 AI Crypto Analyst execution completed successfully!")
        return 0
        
    except KeyboardInterrupt:
        print("\n🛑 Analysis stopped by user (Ctrl+C)")
        if logger is not None:
            logger.warning("⚠️  Analysis interrupted by user")
        return 130
    
    except Exception as e:
        error_msg = f"💥 Unexpected error: {e}"
        print(f"\n{error_msg}")
        
        if logger is not None:
            logger.error(error_msg)
            if args is not None and args.debug:
                logger.exception("Full error traceback:")
        
        return 1


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)